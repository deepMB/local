from typing import TypedDict, List, Optional, Any, Dict, Literal
from langgraph import StateGraph, END
from langchain_core.messages import HumanMessage, SystemMessage
from langchain_core.tools import BaseTool
from langchain_openai import ChatOpenAI
from langchain.agents import create_react_agent, AgentExecutor
from langchain_core.prompts import PromptTemplate
import json
import re
from pydantic import BaseModel, Field

# Agent State Definition
class AgentState(TypedDict):
    """
    Defines the shared state for the playbook-driven multi-agent system.
    """
    error_code: int
    sop_content: str
    
    playbook: Optional[Dict[str, Any]]
    """The structured JSON workflow graph generated by the Planning Agent."""

    execution_queue: List[str]
    """A queue of node IDs from the playbook that the Execution Agent needs to process."""
    
    data: Optional[Any]
    """Holds operational data, like the pandas DataFrame for error 935."""

    last_tool_result: Optional[Dict[str, Any]]
    """Stores the output from the last executed tool for conditional evaluation."""

    final_output: Dict[str, Any]
    """A dictionary to accumulate final results and statuses from the workflow."""

    current_step_id: Optional[str]
    """Currently executing step ID."""

    execution_status: str
    """Status of execution: 'planning', 'executing', 'completed', 'failed'."""

    execution_log: List[Dict[str, Any]]
    """Log of all executed steps and their results."""


# Playbook Schema for structured output
class PlaybookStep(BaseModel):
    """Represents a single step in the playbook"""
    id: str = Field(description="Unique identifier for the step")
    name: str = Field(description="Human-readable name of the step")
    action: str = Field(description="The action to be performed")
    tool_name: Optional[str] = Field(description="Name of the tool to use, if applicable")
    tool_args: Optional[Dict[str, Any]] = Field(description="Arguments for the tool")
    condition: Optional[str] = Field(description="Condition to evaluate for branching")
    next_steps: Dict[str, str] = Field(description="Next steps based on conditions (success, failure, etc.)")
    description: str = Field(description="Detailed description of what this step does")


class PlanningAgent:
    """
    Planning Agent that reads SOPs and creates structured JSON playbooks.
    """
    
    def __init__(self, llm: ChatOpenAI, available_tools: List[BaseTool]):
        self.llm = llm
        self.available_tools = available_tools
        self.tool_names = [tool.name for tool in available_tools]
        
    def analyze_sop(self, state: AgentState) -> AgentState:
        """
        Analyzes the SOP content and creates a structured playbook.
        """
        print("üîç Planning Agent: Starting SOP analysis...")
        
        sop_content = state["sop_content"]
        error_code = state["error_code"]
        
        # Update execution status
        state["execution_status"] = "planning"
        
        # Create detailed tool descriptions
        tool_descriptions = []
        for tool in self.available_tools:
            tool_descriptions.append(f"- {tool.name}: {tool.description}")
        
        # Create the system prompt for SOP analysis
        system_prompt = f"""
        You are an expert SOP (Standard Operating Procedure) analyzer and workflow designer.
        
        Your task is to analyze the given SOP content and create a structured JSON playbook that can be executed by an automation agent.
        
        AVAILABLE TOOLS (YOU MUST ONLY USE THESE TOOLS):
        {chr(10).join(tool_descriptions)}
        
        CRITICAL RULES:
        1. You can ONLY use tools from the available tools list above
        2. Do NOT create, invent, or reference any tools not in the list
        3. If a step requires a tool that's not available, use "action": "notify" instead
        4. Map each SOP step to the most appropriate available tool
        5. If no suitable tool exists for a step, make it a notification step
        
        Guidelines for creating the playbook:
        1. Break down the SOP into discrete, actionable steps
        2. Identify decision points and conditional logic (IF/ELSE scenarios)
        3. Map each step to appropriate tools where applicable (ONLY from available tools)
        4. Create a flow that handles both success and failure paths
        5. Ensure each step has clear next steps based on outcomes
        6. Use meaningful IDs for steps (e.g., "step_001_validate_data", "step_002_check_connection")
        
        For conditional steps:
        - Use "condition" field to specify what to evaluate
        - Use "next_steps" to define paths: {{"success": "next_step_id", "failure": "error_step_id", "default": "default_step_id"}}
        
        The playbook should be comprehensive enough that an execution agent can follow it step-by-step without ambiguity.
        
        Error Code Context: {error_code}
        
        IMPORTANT: Return ONLY the JSON playbook, no other text or explanations.
        """
        
        human_prompt = f"""
        Create a detailed JSON playbook for this SOP:
        
        {sop_content}
        
        Required JSON structure:
        {{
            "name": "Playbook name",
            "description": "What this playbook does",
            "start_step": "first_step_id",
            "steps": {{
                "step_id": {{
                    "id": "step_id",
                    "name": "Step name",
                    "action": "execute_tool|evaluate_condition|notify|end",
                    "tool_name": "tool_name_if_applicable",
                    "tool_args": {{"arg": "value"}},
                    "condition": "condition_to_evaluate_if_applicable",
                    "next_steps": {{"success": "next_id", "failure": "error_id", "default": "END"}},
                    "description": "What this step does"
                }}
            }}
        }}
        
        IMPORTANT RULES:
        1. Use "END" (uppercase) for terminal steps in next_steps
        2. Never use "end", "stop", "finish" - always use "END"
        3. Ensure all referenced step IDs actually exist in the steps dictionary
        4. Every step must have a valid next_steps path
        """
        
        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=human_prompt)
        ]
        
        try:
            # Get structured output from LLM
            response = self.llm.invoke(messages)
            
            # Parse the response to extract JSON
            playbook_json = self._extract_json_from_response(response.content)
            
            # Validate and structure the playbook
            playbook = self._validate_and_structure_playbook(playbook_json)
            
            # Update state with the created playbook
            state["playbook"] = playbook
            state["execution_queue"] = [playbook["start_step"]] if playbook else []
            state["execution_status"] = "ready_to_execute"
            
            print(f"‚úÖ Planning Agent: Successfully created playbook with {len(playbook.get('steps', {}))} steps")
            print(f"üìã Start step: {playbook['start_step']}")
            
        except Exception as e:
            print(f"‚ùå Planning Agent Error: {str(e)}")
            state["playbook"] = None
            state["execution_queue"] = []
            state["execution_status"] = "failed"
            state["final_output"]["error"] = f"Planning failed: {str(e)}"
        
        return state
    
    def _extract_json_from_response(self, response_content: str) -> Dict[str, Any]:
        """Extracts JSON from the LLM response."""
        # Try to find JSON block in the response
        json_pattern = r'```json\s*(.*?)\s*```'
        json_match = re.search(json_pattern, response_content, re.DOTALL)
        
        if json_match:
            json_str = json_match.group(1)
        else:
            # Try to find JSON without code blocks
            json_str = response_content.strip()
        
        try:
            return json.loads(json_str)
        except json.JSONDecodeError as e:
            # Fallback: try to extract JSON from anywhere in the text
            json_start = response_content.find('{')
            json_end = response_content.rfind('}') + 1
            
            if json_start != -1 and json_end > json_start:
                json_str = response_content[json_start:json_end]
                return json.loads(json_str)
            else:
                raise ValueError(f"Could not extract valid JSON from response: {str(e)}")
    
    def _validate_and_structure_playbook(self, playbook_json: Dict[str, Any]) -> Dict[str, Any]:
        """Validates the playbook structure and ensures only valid tools are used."""
        if "steps" not in playbook_json:
            raise ValueError("Playbook must contain 'steps' field")
        
        if "start_step" not in playbook_json:
            playbook_json["start_step"] = list(playbook_json["steps"].keys())[0]
        
        # Validate that start_step exists in steps
        if playbook_json["start_step"] not in playbook_json["steps"]:
            raise ValueError(f"Start step '{playbook_json['start_step']}' not found in steps")
        
        # Ensure each step has required fields and validate tool usage
        for step_id, step_data in playbook_json["steps"].items():
            if "id" not in step_data:
                step_data["id"] = step_id
            if "next_steps" not in step_data:
                step_data["next_steps"] = {"default": "END"}
            if "action" not in step_data:
                step_data["action"] = "execute_tool"
                
            # Validate tool usage - CRITICAL FIX
            if step_data.get("tool_name") and step_data["tool_name"] not in self.tool_names:
                print(f"‚ö†Ô∏è  Warning: Invalid tool '{step_data['tool_name']}' in step '{step_id}'. Converting to notification step.")
                step_data["action"] = "notify"
                step_data["description"] = f"Manual step required: {step_data.get('description', 'Execute manually')}"
                if "tool_name" in step_data:
                    del step_data["tool_name"]
                if "tool_args" in step_data:
                    del step_data["tool_args"]
                
            # Normalize any end step references to uppercase END
            if "next_steps" in step_data:
                normalized_next_steps = {}
                for condition, next_step in step_data["next_steps"].items():
                    if isinstance(next_step, str) and next_step.lower() in ['end', 'stop', 'finish', 'complete']:
                        normalized_next_steps[condition] = "END"
                    else:
                        normalized_next_steps[condition] = next_step
                step_data["next_steps"] = normalized_next_steps
        
        return playbook_json


class ExecutionAgent:
    """
    Enhanced Execution Agent that uses ReAct pattern for intelligent tool selection and execution.
    """
    
    def __init__(self, llm: ChatOpenAI, available_tools: List[BaseTool]):
        self.llm = llm
        self.available_tools = available_tools
        self.tool_dict = {tool.name: tool for tool in available_tools}
        
        # Create ReAct agent executor with enhanced prompting
        react_template = """You are an intelligent execution agent that analyzes step requirements and decides which tools to use.

Available tools:
{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do and which tool is most appropriate
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original question

IMPORTANT RULES:
1. Always analyze the step requirements before selecting a tool
2. If no suitable tool exists for the step, respond with "NO_SUITABLE_TOOL"
3. Evaluate tool results carefully to determine success/failure
4. Be explicit about whether the step succeeded or failed

Begin!

Question: {input}
Thought:{agent_scratchpad}"""

        self.react_prompt = PromptTemplate.from_template(react_template)
        
        # Create ReAct agent
        self.react_agent = create_react_agent(
            llm=self.llm,
            tools=self.available_tools,
            prompt=self.react_prompt
        )
        
        # Create agent executor with error handling
        self.agent_executor = AgentExecutor(
            agent=self.react_agent,
            tools=self.available_tools,
            verbose=True,
            handle_parsing_errors=True,
            max_iterations=3,
            return_intermediate_steps=True
        )
        
    def execute_step(self, state: AgentState) -> AgentState:
        """
        Executes the current step using intelligent ReAct agent decision making.
        """
        if not state["execution_queue"]:
            state["execution_status"] = "completed"
            return state
            
        current_step_id = state["execution_queue"][0]
        state["current_step_id"] = current_step_id
        
        print(f"üîß Execution Agent: Processing step '{current_step_id}'")
        
        # Handle END step (case-insensitive)
        if current_step_id.upper() == "END":
            state["execution_status"] = "completed"
            state["execution_queue"] = []
            print("‚úÖ Execution Agent: Workflow completed successfully")
            return state
        
        # Get current step details
        if not state["playbook"] or current_step_id not in state["playbook"]["steps"]:
            # Check if it's a variation of END
            if current_step_id.lower() in ['end', 'stop', 'finish', 'complete']:
                state["execution_status"] = "completed"
                state["execution_queue"] = []
                print("‚úÖ Execution Agent: Workflow completed successfully")
                return state
            else:
                state["execution_status"] = "failed"
                state["final_output"]["error"] = f"Step '{current_step_id}' not found in playbook"
                return state
            
        current_step = state["playbook"]["steps"][current_step_id]
        
        try:
            # Execute the step using intelligent ReAct agent
            if current_step["action"] == "execute_tool":
                result = self._intelligent_tool_execution(current_step, state)
            elif current_step["action"] == "evaluate_condition":
                result = self._intelligent_condition_evaluation(current_step, state)
            elif current_step["action"] == "notify":
                result = self._notify_step(current_step, state)
            else:
                result = {"status": "success", "message": f"Executed step: {current_step['name']}"}
            
            # Check if execution failed due to no suitable tool
            if result.get("no_suitable_tool"):
                print(f"üõë No suitable tool found for step '{current_step_id}'. Ending workflow.")
                state["execution_status"] = "failed"
                state["final_output"]["error"] = f"No suitable tool available for step '{current_step_id}'"
                return state
            
            # Log the execution
            log_entry = {
                "step_id": current_step_id,
                "step_name": current_step.get("name", ""),
                "result": result,
                "timestamp": "now"
            }
            
            if "execution_log" not in state:
                state["execution_log"] = []
            state["execution_log"].append(log_entry)
            
            # Store last tool result
            state["last_tool_result"] = result
            
            # Intelligently determine next step using ReAct agent
            next_step_id = self._intelligent_next_step_decision(current_step, result, state)
            
            # Update execution queue
            state["execution_queue"] = state["execution_queue"][1:]  # Remove current step
            
            if next_step_id and next_step_id != "END":
                state["execution_queue"].insert(0, next_step_id)  # Add next step to front
            
            print(f"‚úÖ Step '{current_step_id}' completed. Next: '{next_step_id}'")
            
        except Exception as e:
            print(f"‚ùå Execution Agent Error in step '{current_step_id}': {str(e)}")
            state["execution_status"] = "failed"
            state["final_output"]["error"] = f"Execution failed at step '{current_step_id}': {str(e)}"
            
        return state
    
    def _intelligent_tool_execution(self, step: Dict[str, Any], state: AgentState) -> Dict[str, Any]:
        """
        Use ReAct agent to intelligently select and execute tools for the step.
        """
        step_description = step.get("description", "")
        step_name = step.get("name", "Unnamed Step")
        suggested_tool = step.get("tool_name")
        suggested_args = step.get("tool_args", {})
        context = state.get("last_tool_result", {})
        
        # Create intelligent question for ReAct agent
        question = f"""
        STEP EXECUTION REQUEST:
        
        Step Name: {step_name}
        Step Description: {step_description}
        Suggested Tool: {suggested_tool}
        Suggested Arguments: {json.dumps(suggested_args)}
        
        Context from Previous Steps:
        {json.dumps(context, indent=2)}
        
        TASK: Analyze this step and determine the best approach:
        1. If the suggested tool is appropriate and available, use it with the suggested arguments
        2. If the suggested tool is not suitable, select a more appropriate tool from available options
        3. If no suitable tool exists for this step, respond with "NO_SUITABLE_TOOL"
        4. Execute the selected tool and evaluate the result
        5. Determine if the execution was successful or failed based on the tool output
        
        Important: Be thorough in your analysis and execution.
        """
        
        try:
            print(f"ü§ñ ReAct Agent analyzing step: {step_name}")
            print(f"üéØ Suggested tool: {suggested_tool}")
            
            # Use ReAct agent to intelligently execute the step
            result = self.agent_executor.invoke({"input": question})
            
            # Extract detailed information from the result
            final_answer = result.get('output', '')
            intermediate_steps = result.get('intermediate_steps', [])
            
            # Check if agent determined no suitable tool exists
            if "NO_SUITABLE_TOOL" in final_answer:
                return {
                    "status": "failed",
                    "no_suitable_tool": True,
                    "message": "No suitable tool available for this step",
                    "agent_reasoning": final_answer
                }
            
            # Extract tool execution details
            tool_results = []
            actual_tool_used = None
            actual_tool_args = None
            
            for step_info in intermediate_steps:
                if len(step_info) >= 2:
                    action = step_info[0]
                    observation = step_info[1]
                    
                    if hasattr(action, 'tool'):
                        actual_tool_used = action.tool
                        actual_tool_args = action.tool_input
                    
                    tool_results.append({
                        "action": str(action),
                        "observation": str(observation)
                    })
            
            # Determine success based on agent's final answer and tool results
            success_indicators = ['success', 'completed', 'valid', 'connected', 'executed', 'working']
            failure_indicators = ['failed', 'error', 'invalid', 'disconnected', 'timeout', 'exception']
            
            final_answer_lower = final_answer.lower()
            is_successful = False
            
            # Check for explicit success/failure indicators
            if any(indicator in final_answer_lower for indicator in success_indicators):
                is_successful = True
            elif any(indicator in final_answer_lower for indicator in failure_indicators):
                is_successful = False
            else:
                # Fallback: check if tool was executed without errors
                is_successful = len(tool_results) > 0 and not any('error' in str(result).lower() for result in tool_results)
            
            return {
                "status": "success" if is_successful else "failure",
                "tool_used": actual_tool_used or suggested_tool,
                "tool_args": actual_tool_args or suggested_args,
                "tool_results": tool_results,
                "agent_reasoning": final_answer,
                "intermediate_steps": intermediate_steps,
                "message": f"{'Successfully executed' if is_successful else 'Failed to execute'} step using ReAct agent"
            }
            
        except Exception as e:
            print(f"‚ùå Error in intelligent tool execution: {str(e)}")
            return {
                "status": "failure",
                "error": str(e),
                "message": f"Failed to execute step: {str(e)}"
            }
    
    def _intelligent_condition_evaluation(self, step: Dict[str, Any], state: AgentState) -> Dict[str, Any]:
        """
        Use ReAct agent to intelligently evaluate conditions based on previous results.
        """
        condition = step.get("condition", "")
        last_result = state.get("last_tool_result", {})
        execution_log = state.get("execution_log", [])
        
        evaluation_question = f"""
        CONDITION EVALUATION REQUEST:
        
        Condition to Evaluate: {condition}
        
        Previous Step Result:
        {json.dumps(last_result, indent=2)}
        
        Full Execution Context:
        {json.dumps(execution_log[-3:], indent=2) if execution_log else 'No previous steps'}
        
        TASK: Analyze the condition against the available context and determine:
        1. Whether the condition is met (True/False)
        2. Provide clear reasoning for your decision
        3. Consider both explicit status indicators and implicit success/failure signals
        
        Be thorough in your analysis and provide explicit True/False determination.
        """
        
        try:
            # Use ReAct agent for intelligent condition evaluation
            result = self.agent_executor.invoke({"input": evaluation_question})
            
            final_answer = result.get('output', '').lower()
            
            # Parse the agent's decision
            condition_met = False
            if 'true' in final_answer or 'condition is met' in final_answer or 'satisfied' in final_answer:
                condition_met = True
            elif 'false' in final_answer or 'condition is not met' in final_answer or 'not satisfied' in final_answer:
                condition_met = False
            else:
                # Fallback based on last result status
                condition_met = last_result.get("status") == "success"
            
            return {
                "status": "success" if condition_met else "failure",
                "condition": condition,
                "condition_met": condition_met,
                "agent_reasoning": result.get('output', ''),
                "message": f"Condition '{condition}' evaluated to {condition_met}"
            }
            
        except Exception as e:
            print(f"‚ùå Error in intelligent condition evaluation: {str(e)}")
            # Fallback to simple evaluation
            condition_met = last_result.get("status") == "success"
            return {
                "status": "success" if condition_met else "failure",
                "condition": condition,
                "condition_met": condition_met,
                "error": str(e),
                "message": f"Condition '{condition}' evaluated to {condition_met} (fallback)"
            }
    
    def _intelligent_next_step_decision(self, current_step: Dict[str, Any], result: Dict[str, Any], state: AgentState) -> str:
        """
        Use ReAct agent to intelligently decide the next step based on current result.
        """
        next_steps = current_step.get("next_steps", {})
        
        if len(next_steps) <= 1:
            # Simple case - only one path
            return next_steps.get("default", "END")
        
        # Complex case - use ReAct agent for decision
        decision_question = f"""
        NEXT STEP DECISION REQUEST:
        
        Current Step: {current_step.get('name', 'Unknown')}
        Step Result: {json.dumps(result, indent=2)}
        
        Available Next Steps:
        {json.dumps(next_steps, indent=2)}
        
        TASK: Based on the step result, determine which next step should be taken:
        1. Analyze the step result status and outcome
        2. Match it against the available next step conditions
        3. Select the most appropriate next step
        4. Respond with the exact step ID from the available options
        
        Consider:
        - If result status is 'success', typically choose 'success' path
        - If result status is 'failure', typically choose 'failure' path
        - If specific conditions are mentioned, evaluate them against the result
        - Use 'default' path if no specific condition matches
        """
        
        try:
            agent_result = self.agent_executor.invoke({"input": decision_question})
            decision = agent_result.get('output', '').strip()
            
            # Extract the step ID from the agent's response
            for step_id in next_steps.values():
                if step_id in decision:
                    return step_id
            
            # Fallback to traditional logic
            result_status = result.get("status", "unknown")
            
            if result_status in next_steps:
                return next_steps[result_status]
            elif "default" in next_steps:
                return next_steps["default"]
            else:
                return "END"
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error in intelligent next step decision: {str(e)}")
            # Fallback to simple logic
            result_status = result.get("status", "unknown")
            
            if result_status in next_steps:
                return next_steps[result_status]
            elif "default" in next_steps:
                return next_steps["default"]
            else:
                return "END"
    
    def _notify_step(self, step: Dict[str, Any], state: AgentState) -> Dict[str, Any]:
        """Handle notification steps."""
        message = step.get("description", "Notification step executed")
        
        print(f"üì¢ Notification: {message}")
        
        return {
            "status": "success",
            "message": f"Notification sent: {message}"
        }


def create_multi_agent_workflow(llm: ChatOpenAI, available_tools: List[BaseTool]) -> StateGraph:
    """
    Creates the multi-agent workflow with both Planning and Execution agents.
    """
    planning_agent = PlanningAgent(llm, available_tools)
    execution_agent = ExecutionAgent(llm, available_tools)
    
    # Create the state graph
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("planning", planning_agent.analyze_sop)
    workflow.add_node("execution", execution_agent.execute_step)
    
    # Set entry point
    workflow.set_entry_point("planning")
    
    # Define routing logic
    def route_after_planning(state: AgentState) -> Literal["execution", "__end__"]:
        """Route after planning phase."""
        if state["execution_status"] == "ready_to_execute" and state["execution_queue"]:
            return "execution"
        else:
            return "__end__"
    
    def route_after_execution(state: AgentState) -> Literal["execution", "__end__"]:
        """Route after execution phase."""
        if state["execution_status"] == "completed" or state["execution_status"] == "failed":
            return "__end__"
        elif state["execution_queue"]:
            return "execution"
        else:
            return "__end__"
    
    # Add conditional edges
    workflow.add_conditional_edges(
        "planning",
        route_after_planning,
        {
            "execution": "execution",
            "__end__": END
        }
    )
    
    workflow.add_conditional_edges(
        "execution",
        route_after_execution,
        {
            "execution": "execution",
            "__end__": END
        }
    )
    
    return workflow


# Example usage and testing
if __name__ == "__main__":
    from langchain_core.tools import tool
    
    # Mock tools for demonstration
    @tool
    def validate_data(data_source: str) -> str:
        """Validates data from the specified source."""
        return f"Data validation completed for {data_source} - Status: Valid"
    
    @tool
    def check_database_connection(database_name: str) -> str:
        """Checks connection to the specified database."""
        return f"Database connection verified for {database_name} - Status: Connected"
    
    @tool
    def execute_query(query: str) -> str:
        """Executes a database query."""
        return f"Query executed successfully: {query} - Rows affected: 150"
    
    @tool
    def send_notification(message: str, recipient: str) -> str:
        """Sends a notification message."""
        return f"Notification sent to {recipient}: {message} - Status: Delivered"
    
    # Initialize LLM (replace with your preferred LLM)
    llm = ChatOpenAI(model="gpt-4", temperature=0)
    
    # Available tools
    tools = [validate_data, check_database_connection, execute_query, send_notification]
    
    # Create the multi-agent workflow
    workflow = create_multi_agent_workflow(llm, tools)
    
    # Compile the graph
    app = workflow.compile()
    
    # Example SOP content
    sample_sop = """
    SOP for Error Code 935 - Data Validation Failure
    
    1. First, validate the incoming data source 'customer_data'
    2. If validation fails, check database connection to 'main_db'
    3. If connection is successful, execute repair query 'UPDATE customers SET status = active WHERE status IS NULL'
    4. If repair is successful, re-validate the data source
    5. If re-validation passes, send success notification to 'admin@company.com'
    6. If any step fails, send error notification with details to 'admin@company.com'
    """
    
    # Test the multi-agent system
    initial_state: AgentState = {
        "error_code": 935,
        "sop_content": sample_sop,
        "playbook": None,
        "execution_queue": [],
        "data": None,
        "last_tool_result": None,
        "final_output": {},
        "current_step_id": None,
        "execution_status": "planning",
        "execution_log": []
    }
    
    # Run the multi-agent workflow
    try:
        print("üöÄ Starting Enhanced Multi-Agent Workflow with Intelligent Execution...")
        print("=" * 70)
        
        result = app.invoke(initial_state)
        
        print("=" * 70)
        print("üìä Final Results:")
        print(f"Execution Status: {result['execution_status']}")
        print(f"Steps Executed: {len(result.get('execution_log', []))}")
        
        if result.get('execution_log'):
            print("\nüìã Detailed Execution Log:")
            for i, log_entry in enumerate(result['execution_log'], 1):
                step_result = log_entry['result']
                print(f"\n{i}. Step: {log_entry['step_name']} (ID: {log_entry['step_id']})")
                print(f"   Status: {step_result.get('status', 'unknown')}")
                print(f"   Message: {step_result.get('message', 'No message')}")
                
                if step_result.get('tool_used'):
                    print(f"   Tool Used: {step_result['tool_used']}")
                
                if step_result.get('agent_reasoning'):
                    reasoning = step_result['agent_reasoning'][:200] + "..." if len(step_result['agent_reasoning']) > 200 else step_result['agent_reasoning']
                    print(f"   Agent Reasoning: {reasoning}")
                
                if step_result.get('no_suitable_tool'):
                    print(f"   ‚ö†Ô∏è  No suitable tool found - workflow terminated")
        
        if result.get('final_output'):
            print(f"\nüéØ Final Output: {result['final_output']}")
            
        # Display playbook that was created
        if result.get('playbook'):
            print(f"\nüìñ Playbook Created:")
            print(f"   Name: {result['playbook'].get('name', 'Unnamed')}")
            print(f"   Description: {result['playbook'].get('description', 'No description')}")
            print(f"   Total Steps: {len(result['playbook'].get('steps', {}))}")
            print(f"   Start Step: {result['playbook'].get('start_step', 'Unknown')}")
    
    except Exception as e:
        print(f"‚ùå Error running enhanced multi-agent workflow: {str(e)}")
        import traceback
        print("Full traceback:")
        traceback.print_exc()


# Additional utility functions for enhanced functionality

def validate_playbook_execution_flow(playbook: Dict[str, Any]) -> List[str]:
    """
    Validates that the playbook has a valid execution flow without dead ends.
    Returns list of validation warnings/errors.
    """
    issues = []
    
    if not playbook or "steps" not in playbook:
        return ["Playbook is empty or missing steps"]
    
    steps = playbook["steps"]
    start_step = playbook.get("start_step")
    
    if start_step not in steps:
        issues.append(f"Start step '{start_step}' not found in steps")
    
    # Check for unreachable steps
    reachable_steps = set()
    to_visit = [start_step] if start_step in steps else []
    
    while to_visit:
        current = to_visit.pop()
        if current in reachable_steps or current == "END":
            continue
        
        reachable_steps.add(current)
        
        if current in steps:
            next_steps = steps[current].get("next_steps", {})
            for next_step in next_steps.values():
                if next_step != "END" and next_step not in reachable_steps:
                    to_visit.append(next_step)
    
    unreachable = set(steps.keys()) - reachable_steps
    if unreachable:
        issues.append(f"Unreachable steps found: {list(unreachable)}")
    
    # Check for missing next step references
    for step_id, step_data in steps.items():
        next_steps = step_data.get("next_steps", {})
        for condition, next_step in next_steps.items():
            if next_step != "END" and next_step not in steps:
                issues.append(f"Step '{step_id}' references non-existent step '{next_step}'")
    
    return issues


def create_execution_summary(execution_log: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Creates a comprehensive summary of the execution.
    """
    if not execution_log:
        return {"total_steps": 0, "successful_steps": 0, "failed_steps": 0}
    
    successful_steps = sum(1 for log in execution_log if log['result'].get('status') == 'success')
    failed_steps = sum(1 for log in execution_log if log['result'].get('status') == 'failure')
    
    tools_used = []
    for log in execution_log:
        tool_used = log['result'].get('tool_used')
        if tool_used and tool_used not in tools_used:
            tools_used.append(tool_used)
    
    return {
        "total_steps": len(execution_log),
        "successful_steps": successful_steps,
        "failed_steps": failed_steps,
        "success_rate": successful_steps / len(execution_log) * 100,
        "tools_used": tools_used,
        "execution_path": [log['step_id'] for log in execution_log]
    }


# Enhanced error handling and recovery mechanisms

class ExecutionRecoveryAgent:
    """
    Optional recovery agent that can attempt to recover from failed steps.
    """
    
    def __init__(self, llm: ChatOpenAI, available_tools: List[BaseTool]):
        self.llm = llm
        self.available_tools = available_tools
    
    def attempt_recovery(self, failed_step: Dict[str, Any], error_result: Dict[str, Any], state: AgentState) -> Dict[str, Any]:
        """
        Attempts to recover from a failed step by suggesting alternative approaches.
        """
        recovery_question = f"""
        STEP RECOVERY REQUEST:
        
        Failed Step: {failed_step.get('name', 'Unknown')}
        Step Description: {failed_step.get('description', '')}
        Error Result: {json.dumps(error_result, indent=2)}
        
        Available Tools: {[tool.name for tool in self.available_tools]}
        
        TASK: Analyze the failure and suggest recovery options:
        1. Identify why the step failed
        2. Suggest alternative tools or approaches
        3. Recommend if recovery is possible or if workflow should terminate
        4. Provide specific recovery steps if applicable
        
        Respond with a structured recovery plan or recommend termination.
        """
        
        try:
            response = self.llm.invoke([HumanMessage(content=recovery_question)])
            
            # Simple recovery logic - in practice, this would be more sophisticated
            if "recovery possible" in response.content.lower():
                return {
                    "recoverable": True,
                    "recovery_plan": response.content,
                    "suggested_action": "retry_with_alternative"
                }
            else:
                return {
                    "recoverable": False,
                    "reason": response.content,
                    "suggested_action": "terminate_workflow"
                }
                
        except Exception as e:
            return {
                "recoverable": False,
                "reason": f"Recovery analysis failed: {str(e)}",
                "suggested_action": "terminate_workflow"
            }